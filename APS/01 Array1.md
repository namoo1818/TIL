### 2023.08.07
# 알고리즘
- 문제를 해결하는 방법
- 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
- 어떠한 문제를 해결하기 위한 절차(APS)

## 컴퓨터 분야에서 알고리즘을 표현하는 방법
#### 1. 자연어
#### 2. 프로그래밍 언어
#### 3. 의사코드(Pesudocode)
  - 의미만 전달할 수 있으면 ok
  - 아래는 예시
```
CalcSum( n ) {
  sum <- 0
  for ( i <- 1; i <= n; i <- i + 1) {
    sum <- sum + i;
  return sum;
}
```
#### 4. 순서도  
![순서도](/images/순서도.PNG)

# 알고리즘 성능
## APS 과정의 목표 중의 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것이다.

## 무엇이 좋은 알고리즘인가?
1. 정확성 : 얼마나 정확하게 동작하는가
2. 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
4. 단순성 : 얼마나 단순한가
5. 최적성 : 더 이상 개선할 여지없이 최적화되었는가

- 주어진 문제를 해결할 수 있는 알고리즘은 다양하다
- 알고리즘의 성능 분석 필요 -> 시간 복잡도  
![알고리즘 성능](/images/알고리즘_성능.PNG)

# 시간 복잡도(Time Complexity)
- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산  
![알고리즘 성능2](/images/알고리즘_성능2.PNG)

# 빅-오(O) 표기법(Big-Oh Notation)
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- 계수(Coefficient)는 생략하여 표시
- 예)
```
O(3n+2) = O(3n) = O(n)
O(2n^2+10n+100) = O(n^2)
O(4) = O(1)
```
- n개의 데이터를 입력 받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 화면에 출력하는 알고리즘의 시간복잡도는 어떻게 되나? **O(n)**

# 다양한 시간 복잡도의 비교  
![시간복잡도_비교](/images/시간복잡도_비교.PNG)

# 배열
- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조  
![배열](/images/배열.PNG)

# 배열의 필요성
- 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.
- 반복문도 가능!

# 1차원 배열의 선언
- 자료형 : 배열을 이루는 자료형
- 이름 : 프로그램에서 사용할 배열의 이름
- 길이 : 배열을 이루는 원소의 수  
![1차원_배열](/images/1차원_배열.PNG)  
![1차원_배열2](/images/1차원_배열2.PNG)
# 1차원 배열의 접근
- num[0] = 10;   // 배열 nums의 0번째 원소에 10을 저장
- num[idx] = 20; // 배열 nums의 idx번째 원소에 20을 저장
- idx = 4는 가넝, idx = -1은 불가넝

# SW 문제를 완벽하게 풀기 위한 5단계
1. 지문을 읽는다.
2. 문제를 이해한다.
3. 문제를 손으로 푼다.
4. 푼 걸 코딩한다.
5. 디버깅하고 검증한다.

# 정렬
- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순:ascending), 혹은 그 반대의 순서대로(내림차순:descending) 재배열하는 것

# 대표적인 정렬 방식의 종류
- 버블 정렬(Bubble Sort)
- 선택 정렬(Selection Sort) 
- 삽입 정렬(Insertion Sort)
- 카운팅 정렬(Counting Sort)
- 병합 정렬(Merge Sort)
- 퀵 정렬(Quick Sort)

# 버블 정렬(Bubble Sort)
- **인접한 두 개의 원소**를 비교하며 자리를 계속 교환하는 방식
- 제자리 정렬
- 안정 정렬
- 정렬 과정
> - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
> - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
> - 교환하며 자리를 이동하는 모습이 물에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.
- 시간복잡도 O(n^2)  
![버블정렬](/images/버블정렬.PNG)
```java
// 오름차순으로 정렬하고 싶어
int[] nums = { 24, 99999, 99, 31, 213124, 7, 35 };
int N = nums.length; // 7
// 사이클 횟수를 위한 반복문
for (int i = 0; i < N - 1; i++) {
  for (int j = 1; j < N - i; j++) {
    // 오름차순이니까
    if( nums[j-1] > nums[j]) {
      int tmp = nums[j];
      nums[j] = nums[j-1];
      nums[j-1] = tmp;
    }
  } // 보글보글 비교하는 반복문
} // 사이클 횟수를 위한 반복문
System.out.println(Arrays.toString(nums));
```
```java
[7, 24, 31, 35, 99, 99999, 213124]
```
