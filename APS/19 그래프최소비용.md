### 2023.09.20
# 서로소 집합 Disjoint-sets
- 상호배타 집합
- 서로 중복 포함된 원소가 없는 집합들. 즉 교집합이 없다
- 대표자로 각 집합들을 구분한다

# 상호배타 집합을 표현하는 방법
- 연결 리스트
- 트리

# 상호배타 집합 연산
- Make-Set(x) : x가 대표자인 집합을 만들어줘
- Find-Set(x) : x가 속한 집합의 대표자를 데려와
- Union(x,y) : x가 속한 집합과 y가 속한 집합을 합쳐라

# 상호 배타 집합 표현 - 트리
- 하나의 집합(a disjoint set)을 하나의 트리로 표현한다
- 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 된다
- 문제점: Find_Set 연산을 할 때 중복 수행이 너무 자주 발생한다.

# 연산의 효율을 높이는 방법
1. Rank를 이용한 Union
   - 각 노드는 자신을 루트로 하는 subtree의 높이를 랭크(rank)라는 이름으로 저장한다
   - 두 집합을 합칠 때 rank가 낮은 집합을 rank가 높은 집합에 붙인다
2. Path compression
   - Find-Set을 행하는 과정에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꾸어 준다
   - Make-Set(x): 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산
  
# 최소 신장 트리(MST)
- 신장 트리: 그래프의 모든 정점과 일부 간선으로 구성되는 트리
- 최소 신장 트리: 신장 트리 중에서 사용된 간선들의 가중치 합이 최소인 트리
- 특징
  1. 무방향 가중치 그래프
  2. 그래프의 가중치의 합이 최소여야 한다.
  3. N개의 정점을 가지는 그래프에 대해 반드시 (N-1)개의 간선을 사용해야 한다.
  4. 사이클을 포함해서는 안된다.
 
- 사용 하는 이유? 도로망, 통신망, 유통망 등등 여러 분야에서 비용을 최소로 해야 그만큼의 이익을 볼 수 있다.
- 대표적인 방법: Kruskal, Prim

# KRUSKAL 알고리즘
- 간선을 하나씩 선택해서 MST를 찾는 알고리즘
  1. 최초, 모든 간선을 가중치에 따라 **오름차순**으로 정렬
  2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
     - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
  3. n-1개의 간선이 선택될 때까지 2를 반복
 
# KRUSKAL 연습

