### 2023.08.24
# 수식 트리(Expression Binary Tree)
> 수식을 표현하는 이진 트리   
- 연산자는 루트 노드이거나 가지 노드
- 피연산자는 모두 리프 노드

# 힙(Heap)
> 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조
- 완전 이진 트리 : 중간에 빠진 것 없이 왼쪽부터 가득 차있는 트리
### 최대 힙(max heap)
- 키 값이 가장 큰 노드를 찾기 위한 `완전 이진 트리`
- 부모 노드의 키 값 >= 자식 노드의 키 값
- 부모는 자식보다 우선순위가 높다
- 형제끼리는 관련 없다
- 루트 노드 : 키 값이 가장 큰 노드
### 최소 힙(min heap)
- 키 값이 가장 작은 노드를 찾기 위한 `완전 이진 트리`
- 부모 노드의 키 값 <= 자식 노드의 키 값
- 루트 노드 : 키 값이 가장 작은 노드

# 힙 - 삽입
- 시간복잡도 $O(logN)$  
![힙삽입](https://github.com/namoo1818/Baekjoon/assets/50236187/f6f6434d-e556-4c7f-b5ed-a95b65034ec8)
```java
// 힙에 삽입. 최대힙 기준
public static void heapPush(int item) {
  heap[++heapSize] = item; // 마지막 자리에 삽입

  int ch = heapSize; // 자식
  int p = ch / 2; // 부모

  // 정렬
  // 자식 노드 원소가 부모 노드 원소보다 크면 swap
  while (p > 0 && heap[ch] > heap[p]) {
    int tmp = heap[p];
    heap[p] = heap[ch];
    heap[ch] = tmp;
    // 부모 자식을 한레벨 위로 다시 결정
    ch = p;
    p = ch / 2;
  }
}
```

# 힙 - 삭제
- ⭐`힙에서는 루트 노드의 원소만 삭제할 수 있다`
- 루트 노드의 원소를 삭제하여 반환한다
- 힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다
- 1️⃣ 루트 노드를 삭제하고 마지막 자식 노드가 루트 노드로 이동
- 2️⃣ 루트 노드부터 왼자, 오자를 비교하면서 정렬하기
![힙삭제](https://github.com/namoo1818/Baekjoon/assets/50236187/fca845c6-7dda-4268-82b4-0eb6f184fc71)
```java
// 삭제 : 반환 타입은 우리가 heap으로 관리 하고 있는 것으로 한다. 최대힙 기준
public static int heapPop() {
  // 힙이 공백상태라면?
  if (heapSize <= 0)
    return -1; // 주의 요망!

  int item = heap[1]; // 루트노드
  heap[1] = heap[heapSize--]; // 마지막 값을 루트에 덮어씌우기

  int p = 1;
  int ch = p * 2;
  // 앞에 조건은 오자가 있다면~~
  if (ch + 1 <= heapSize && heap[ch] < heap[ch + 1])
    ch += 1; // 만약 오자가 더크면 오자로 변경 세팅

  // 내려가 살수 있는 만큼 내려보내기
  while (ch <= heapSize && heap[p] < heap[ch]) {
    int tmp = heap[p];
    heap[p] = heap[ch];
    heap[ch] = tmp;

    p = ch;
    ch = p * 2;
    // 앞에 조건은 오자가 있다면~~
    if (ch + 1 <= heapSize && heap[ch] < heap[ch + 1])
      ch += 1; // 만약 오자가 더크면 오자로 변경 세팅
  }

  return item;
}
```
# 힙을 활용한 우선순위 큐
- 노드 하나 추가/삭제의 시간복잡도가 $O(logN)$이고 최대값/최소값을 $O(1)$에 구할 수 있다.
- **배열**을 통해 트리 형태를 쉽게 구현할 수 있다.
- 부모나 자식 노드를 $O(1)$ 연산으로 쉽게 찾을 수 있다.
- n 위치에 있는 노드의 자식은 2*n과 (2*n)+1에 위치한다.
- 완전 이진 트리의 특성에 의해 추가/삭제의 위치는 자료의 시작과 끝 인덱스로 쉽게 판단할 수 있다.
- java.util.PriorityQueue

# 힙 정렬
- 힙 정렬은 힙 자료구조를 이용해서 이진 트리와 유사한 방법으로 수행된다
- 1️⃣ 하나의 값을 힙에 삽입한다.(반복)
- 2️⃣ 힙에서 순차적(오름차순)으로 값을 하나씩 제거한다.
- 시간복잡도 $O(logN)$
- 힙 정렬은 배열에 저장된 자료를 정렬하기에 유용하다.
